* 아나콘다 설치되었다는 가정하에
   Jupyter 를 설치해보도록 한다.
1. 윈도우 전체창에서 맨 아래쪽에 검색이 보인다.
    Anaconda Prompt를 실행시키도록 한다.
2. 실행시킨다음에 아래 명령을 통해서
    GUI 그래픽상에 그래프를 그려주는
    matplotlib을 설치하도록 한다.
    conda install matplotlib
    마지막에 설치를 수행하겠냐고 묻는데 y를 누르면됨
3. 또한 scikit-learn 이라는 모듈을 설치해야 한다.
    conda install scikit-learn
4. 위의 두 가지가 모두 설치되면 jupyter를 설치할 수 있다.
    conda install jupyter
5. TF로 유명한 TensorFlow를 설치해보도록 하자
    conda install tensorflow
6. 만약 TF가 잘 설치되었다면 keras를 설치한다.
    conda install keras
7. keras 까지 설치가 잘 되었다면
    이제 Jupyter를 실행하도록 한다.
    윈도우 전체창 검색에서 Anaconda Navigator를 킨다.
8. 그러면 Navigator에 jupyter라는 것이 보일 것이다.
    요 녀석을 Launch 눌러서 실행시키도록 한다.
9. 현재 띄워진 창의 위치를 확인하고
    해당 디렉토리로 이동하여
    jupyter_workspace 폴더를 만든다.
10. jupyter_workspace를 눌러서 들어간다.
11. 우측 상단의 New를 누르면
     폴더, 파일, python3 등의 옵션이 나온다.
     우리는 python3 개발이므로 python3를 누르면 된다.
12. 그러면 Python 프로그램을 실행해 볼 수 있는
     웹 UI 창이 나타나게 된다.
13. File -> Save as ... 로 파일 이름을 지정할 수 있다.
ex1)
print("Hello Python Programming")
print('Hello Python Programming')
ex2)
Num = 3.3
num = 7
print(num, Num)
ex3)
# 파이썬 주석은 요렇게
# 파이썬 진영을 데이터 과학자, 일반 과학자들이 좋아하는 이유가
# 아래와 같은 수식 연산들을 언어 차원에서 지원해주고 있기 때문이다.
# 벡터, 행렬 - 선형대수
# (통계, 미적분) - 각각을 따로 공부해야함
# 공업수학(라플라스 변환, 푸리에 변환)
# i를 j로 표현하는 이유가 전류 기호가 i이기 때문이다.
# i가 혼선을 유발할 수 있으므로 복소수 표현시 j를 사용하는 것을 추천한다.
z = 3 + 4j
print(type(z))
print("z.imag =", z.imag)
print("z.imag = " + str(z.imag))
print(z.real)
print(z.conjugate())
ex4)
z1 = 3 + 4j # 객체 1
z2 = 2 - 2j # 객체 2
# Operator Overload(연산자 오버로딩)
# if) Java -> z1.sub(z2)
# class complex {
#   float real, imag
#
#   public complex sub(complex other) {
#      complex res = new complex()
#      res.real = real - other.real
#      res.imag = imag - other.imag
#      return res
#   }
# }
res = z1 - z2
print("res =", res)
ex5)
big = 1.2e30 # 1.2 x 10의 30승 (e가 Euler 상수가 아님)
small = 1.57e-20 # 1.57 x 10의 -20승 (1.57 * 10^-20)
test = 2 ** 10 # 2^10
print(big)
print(small)
print(test)
print(type(big))
print(type(small))
print(type(test))
ex6)
# 파이썬은 데이터 타입이 없다!
num1 = 7 / 3   # 데이터 타입이 없다보니 소수점이 나오면 자동으로 float 처리
num2 = 7 // 3  # 나눗셈의 몫만 계산하도록 만들어준다.
print(num1)
print(num2)
ex7)
# 쌍따옴표 3개를 쓰면 문자열의 출력 형식을 작성한 그대로 유지할 수 있다.
fixStr = """
        오늘도 간다 ~
            내일도 간다 ~
                모레도 간다 ~
"""
print(fixStr)
ex8)
testStr = 'test' + ' python'
print(testStr)
ex9)
str = "pointer"
print(str)
print(str[0])
print(str[3])
ex10)
str = "pointer"
print(str[0:1])    # 0 부터 1 미만 (0을 포함, 1은 포함하지 않음)
print(str[1:4])    # 1 부터 4 미만 (1, 2, 3)
print(str[:2])     # 생략은 0 이므로 (0, 1)
print(str[-2:])    # (-2, -1) 음수이므로 거꾸로
print(str[:])      # 그냥 전부 다
print(str[::2])    # 전부 다 뿌리는데 2칸씩 건너뜀
print(str[::3])
print('##########')
print(str[-5:-2]) # -5, -4, -3
print(str[-5:5])  # -5, -4, -3   얘는 문자가 연결이 되서 출력 가능
print(str[-3:2])  # -3부터 2까지 연결이 안되서 출력 불가
print(str[-5:7])
# [시작:끝:스텝] ---> 스텝: 값을 몇 씩 올릴 것인가(for문의 증감부 같은거라 생각)
ex11)
# 파이썬은 자바와 같이 Collection 등을 활용하지 않더라도 쉽게 리스트를 만들 수 있다.
colors = ["red", "green", "blue"]
print(colors)
print(type(colors))
ex12)
colors = ["red", "green", "blue"]
colors.append("gold")             # 맨 마지막 원소에 값을 배치한다.
print(colors)
ex13)
colors = ["red", "green", "blue"]
colors.insert(1, 'black')         # 1번 자리에 값을 배치한다.
                                  # 기존에 있던 값은 뒤로 1칸씩 밀려난다.
print(colors)
ex14)
colors = ["red", "green", "blue"]
colors.extend(["yellow", "pink"])   # 리스트에 리스트를 붙일 수 있다.
print(colors)
ex15)
colors = ["red", "green", "blue"]
colors += ['purple']               # sum += account -> sum = sum + account
                                   # colors = colors + ['purple']
colors += ['red']
print(colors)
ex16)
colors = ["red", "green", "blue"]
colors.append("gold")
colors.insert(1, 'black')
colors.extend(["yellow", "pink"])
colors += ['purple']
colors += ['red']
#    0       1        2        3       4       5        6         7        8
# ["red", "black", "green", "blue", "gold", "yellow", "pink", "purple", "red"]
print(colors.index('purple'))    # 인자로 들어온 원소의 인덱스를 찾음
print(colors.index('red'))
print(colors.index('red', 1))    # 두번째 인자는 시작 위치
#print(colors.index('purple', 0, 3))    # 세번째 인자는 끝 위치
print(colors.index('purple', 4, 8))     # 못찾으면 오류가 발생!
ex17)
colors = ["red", "black", "green", "blue", "gold", "yellow", "pink", "purple", "red"]
print(colors.count('red'))
ex18)
colors = ["red", "black", "green", "blue", "gold", "yellow", "pink", "purple", "red"]
# 현재 만든 리스트(디폴트 - 스택)
print(colors.pop())
print(colors.pop())
print(colors.pop())
print(colors)
ex19)
colors = ["red", "black", "green", "blue", "gold", "yellow", "pink", "purple", "red"]
colors.remove("green")     # 원하는 원소를 제거한다.
print(colors)
ex20)
colors = ["red", "black", "green", "blue", "gold", "yellow", "pink", "purple", "red"]
colors.sort()     # 정렬
print(colors)
ex21)
colors = ["red", "black", "green", "blue", "gold", "yellow", "pink", "purple", "red"]
colors.reverse()  # 값 뒤집기
print(colors)
ex22)
colors = ["red", "black", "green", "blue", "gold", "yellow", "pink", "purple", "red"]
colors.sort(reverse=True)     # 거꾸로 정렬
print(colors)
ex23)
def mysort1(x):
    return x[-1]     # 맨마지막 글자 하나
def mysort2(x):
    return x[-2]     # 맨마지막 글자 하나
# 낱장으로 보다보니 글자 하나만 봐서
# 앞뒤의 전후 사정을 알 수가 없다.
# 그러므로 동일한 값에 대해서는 순서대로 배치된다.
colors = ["red", "blue", "green", "blve", "gold", "blue", "pink", "purple", "red"]
colors.sort(key=mysort1)
print(colors)
colors = ["red", "black", "green", "blue", "blve", "yellow", "red", "purple", "red"]
colors.sort(key=mysort2)
print(colors)
ex24)
# 중괄호에 넣는 값들은 집합으로 분류된다.
a = {1, 2, 3}
b = {2, 3, 4, 5}
print(a)
print(b)
print(type(a), type(b))
ex25)
a = {1, 2, 3}
b = {2, 3, 4, 5}
print(a.union(b))         # 합집합
print(a.intersection(b))  # 교집합
print(a - b)              # 차집합
print(b - a)              # 차집합의 특징: 빼는 순서에 따라 결과가 바뀐다.
print('##########')
print(a | b)              # OR(합집합)
print(a & b)              # AND(교집합)
print(a ^ b)              # XOR(여집합)
ex26)
# 파이썬은 True 혹은 False로 표기해야한다!
isTrue = False
print(isTrue)
print(type(isTrue))
ex27)
print(1 < 2)
print(1 != 2)           # 같지 않다 x, 같지 않냐 ? o
print(1 == 2)           # 같은거냐 ?
print('#############')
print(True and False)   # and 특징 - 양쪽이 모두 참인 경우에만 참
print(True & True)      # and의 기호식 표현이 &
print(True or False)    # or 특징 - 한쪽이라도 참이면 참
print(False | False)    # or의 기호식 표현이 | (\표시를 shift 누르면 나옴)
print(not False)        # not 특징 - 무조건 반전
ex28)
print("bool(0) =", bool(0))              # 0은 거짓
print("bool(-1) =", bool(-1))            # -1은 참(값이 있으면 참)
print("bool(None) =", bool(None))        # None은 아무것도 없다는 것이므로 거짓
print("bool('test') =", bool('test'))    # 문자열이 있으므로 참
print("bool('') =", bool(''))            # 텅비었으므로 거짓
ex29)
val = 10
# 파이썬에서는 중괄호 없이 콜론으로 스코핑을 한다.
# if나 함수(매서드)나 반복문등의 내부 코드는 들여쓰기로 구분한다.
if val > 5:
    print("%d is bigger than 5" % val)
    print("정말!")
    
# %d는 decimal의 약자로 정수 타입의 숫자를 출력
# %f는 float으로 소수점 타입의 숫자를 출력
# %s는 string으로 문자열을 출력
# 문자열 내부에 %d, %f, %s 등을 표현한다.
# 문자열을 끝내고 뒤에 %를 붙이고 대응시킬 변수들을 넣으면 됨
ex30)
val1 = 3
val2 = 7
fval = 3.3
sval = "test"
print("%d이(가) 나오고, %d도 나오고, %f, %s" % (val1, val2, fval, sval))
ex31)
val = 7
if val > 3:
    print("크다")
else:
    print("작다")
ex32)
val = 1
if val > 3:
    print("크다")
elif val < 3:
    print("작다")
else:
    print("같다")
ex33)
fruits = {"apple":"red", "banana":"yellow"}
# 파이썬에서 해쉬는 dict라고 불리며 key값:value값으로 구성된다.
print(fruits)
print(type(fruits))
ex34)
fruits = {"apple":"red", "banana":"yellow"}
# key값으로 value값을 얻는 모습
print(fruits["apple"])
ex35)
# dict 추가는 + 기호가 필요 없다.
# dict형태[키값] = "밸류값"
fruits["cherry"] = "red"
print(fruits)
ex36)
# 해쉬가 키값을 기반으로 값을 찾는 방식이므로
# 키값으로 검색을 하고 값을 삽입하면 밸류값이 변경된다.
# 키값으로 검색 == fruits["apple"] -> True
fruits["apple"] = "green"
print(fruits)
ex37)
# fruits.items()은 fruits 딕셔너리(dict)에 들어있는 요소들을 가져온다.\
# ('apple', 'green') - 첫번째 요소
# ('banana', 'yellow') - 두번째 요소
# ('cherry', 'red') - 세번째 요소
cnt = 0
# 각각의 키 & 밸류에 해당하는 요소를 c에 가져온다.
for c in fruits.items():
    print(c)
    # 파이썬은 cnt++ 같은 형식이 안된다.
    cnt += 1
    
print(cnt)
ex38)
# k는 key에 대응하며, v는 value에 대응한다.
for k, v in fruits.items():
    print("k =", k)
    print("v =", v)
ex39)
# 1번째 k가 green, v가 apple
for v, k in fruits.items():
    print(k, v)
print('#########')
# k에 key, v에 value값
# 1번째가 k가 apple, v가 green
for k, v in fruits.items():
    print(k, v)
ex40)
# del을 통해 dict를 지울 수 있다.
del fruits['cherry']
print(fruits)
ex41)
# dict형태의 객체를 clear()하면 전부 제거된다.
fruits.clear()
print(fruits)
ex42)
# 파이썬은 아래와 같은 혼성 데이터도 언어 차원에서 지원한다.
test = {'age': 37, 'job':[1, 2, 3], 'name': {'Kim': 2, 'Cho': 1}}
print(test)
print(type(test))
ex43)
l = [3, 7, 33, 77, 333]
# iter는 리스트의 반복할 값을 만들어주는 폼(Form)
iterator = iter(l)
print(type(iterator))
print(type(l))
for i in iterator:
    print(i)
ex44)
# 순차적인 값을 뽑고 싶을때는 range가 더 좋다.
# 반면 순차적인 값이 아니라 무작위 데이터
# 혹은 입력을 통해 획득한 값이라면 iter()를 사용하는 것이 더 좋다.
for i in range(5):
    print(i)
ex45)
numList = [1, 2, 3, 4, 5, 6, 7]
for i in numList:
    if i > 3:
        break;      # 현재 돌고 있는 루프 1개를 빠져나간다.
    # {0}, {1} 요런식으로 적는 것들은 첫번째 인자, 두번째 인자를 의미한다.
    # 현재 예에서는 {0} 이므로 첫번째 인자가 i 임을 의미한다.
    print("Item: {0}".format(i))
ex46)
for i in range(4):
    for j in range(4):
        if j > 2:
            break
        # {0}, {1}을 활용하는 방법 예제
        print("Item: {0}, {1}".format(i, j))
        #print("Item: {0}, {1}, {2}".format(i, j, res))
ex47)
for i in range(10):
    # if (i % 2 == 0)
    # 값이 없거나 비어있는 값은 False
    # 그러나 값이 있는 경우에도 0 에 한해서는 False
    # 1은 참, 0은 거짓
    # 동의어 if (i % 2 == 1)
    if i % 2:        # %는 나머지 연산
        continue     # 더 이상 진행하지 않고 최상위 루프로 되돌아감(증감 진행)
        print("I can't do Anything")
        
    print("Item: {0}".format(i))
ex48)
# pass 는 확인!
for i in range(10):
    # if (i % 2 == 0)
    # 값이 없거나 비어있는 값은 False
    # 그러나 값이 있는 경우에도 0 에 한해서는 False
    if i % 2:
        pass     # pass는 할 일 읎다 ~
        print("There's nothing what I do!")
        
    print("Item: {0}".format(i))
ex49)
# 0 ~ 9 까지 총 10개
# 숫자 10 전까지(10을 포함하지 않음)
print(list(range(10)))
# 첫번째 인자 = 시작값, 두번째 인자 = 끝값(포함하진 않음)
# 5 ~ 9
print(list(range(5, 10)))
# 첫번째 = 시작, 두번째 = 끝(포함 x), 세번째 = 증감
print(list(range(10, 0, -1)))
print(list(range(10, 20, 2)))   # 증감 2이므로 2칸씩 건너뜀
ex50)
strList = ['Apple', 'Banana', 'Orange', 'Cherry']
print(strList)
# len은 요소의 개수를 구하는 부분에 활용이 가능
print(len(strList))
print(range(len(strList)))
# 0 ~ 3 총 4번 루프를 돈다.
for i in range(len(strList)):
    print("idx: {0}, val: {1}".format(i, strList[i]))
ex51)
# 인자가 1개인 GetBiggerThan20 함수(매서드)
# def를 적으면 함수를 선언하는 작업
def GetBiggerThan20(i):
    return i > 20
numList = [10, 25, 30]
# 람다식, 람다스타일, 함수형 프로그래밍
# filter라는 것은 일반적으로 조건식에 사용함
# 함수포인터 - C, C++ 개념
# 클래스를 new 하면 객체
# 이 안에는 클래스의 변수들과 매서드가 존재
# 여기서 매서드만 따로 뽑아서 객체화 한다고 생각하면 그것이 바로 람다
# 이 스타일은 사실 C, C++ 스타일에 해당함
iterList = filter(GetBiggerThan20, numList)
for i in iterList:
    print("Item: {0}".format(i))
ex52)
numList = [10, 25, 30]
# 여기서 보이는 스타일은 순수 람다 스타일
iterList = filter(lambda i: i > 20, numList)
for i in iterList:
    print("Item: {0}".format(i))
ex53)
numList = [1, 2, 3]
def Add10(i):
    return i + 10
# map은 주로 순수한 계산식들에 활용됨
for i in map(Add10, numList):
    print("Item: {0}".format(i))
ex54)
retList = list(map((lambda i: i + 10), numList))
print(retList)
ex55)
import time
l = range(100000)
# 현재 시간을 구해옵니다 ~
t = time.mktime(time.localtime())
# 100만개를 뿌립니다 ~
for i in l:
    print(i,)
# 현재 시간을 구해서 이전에 구한 시간을 뺀다.
# 즉 for문 100만개를 도는데 걸린 시간을 측정할 수 있다.
t1 = time.mktime(time.localtime()) - t
# 현재 시간을 구해옵니다 ~
t = time.mktime(time.localtime())
# l(list)에 있는 값들을 for를 돌면서 가져올 것이다.
# 각각을 str(i)에 지정해줄 것인데
# join을 통해 각각을 병렬화하고 고속화 할 수 있다.
print(", ".join(str(i) for i in l))
t2 = time.mktime(time.localtime()) - t
print("Take {0} seconds".format(t1))
print("Take {0} seconds".format(t2))
# Memory Hierarchy(메모리 계층 구조)
# 1. Register(레지스터)
# 2. Cache(캐시): SRAM
# 3. Memory(메모리): DRAM
# 4. I/O(대표적인 장치는 디스크, 모니터, 키보드 등등)
# 숫자가 작을수록 
